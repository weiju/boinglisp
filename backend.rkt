#lang racket
(provide translate-stream print-prologue print-epilogue)
;; This backend translates the intermediate code generated by the compiler
;; stage into 68k code.
;; Currently the data model is as follows:
;;   - Values are 32 bit
;;   - integers (fixnum) are 31 bits and have their LSB set to 1
;;   - all other values have their LSB set to 0, currently this is
;;     - string pointer
(define (print-prologue)
  (printf "\tcode~n")
  (printf "\txdef\t_bl_main~n")
  (printf "\tcnop\t0,4~n")
  (printf "_bl_main:~n"))

(define (print-epilogue)
  (printf "\tcnop\t0,4~n")
  (printf "epilogue:~n")
  (printf "\tmoveq\t#0,d0~n")
  (printf "\trts~n"))

;; global environment lookup
(define (lookup-variable varname)
  (cond [(eq? varname 'quote) (printf "\tlea\t_bl_quote,a0~n")]
        [(eq? varname 'println) (printf "\tlea\t_bl_println,a0~n")]
        [(eq? varname 'print) (printf "\tlea\t_bl_print,a0~n")]
        [(eq? varname '+) (printf "\tlea\t_bl_add,a0~n")]
        [(eq? varname '-) (printf "\tlea\t_bl_sub,a0~n")]
        [(eq? varname '*) (printf "\tlea\t_bl_mul,a0~n")]
        [(eq? varname '/) (printf "\tlea\t_bl_div,a0~n")]
        [(eq? varname '=) (printf "\tlea\t_bl_num_eq,a0~n")]
        [(eq? varname 'not) (printf "\tlea\t_bl_not,a0~n")]
        ;; TODO: for now only look in tl env
        [else (printf "looking up: ~a~n" varname)]))

;; these branches preserve arg-counts
(define (translate-instr-preserve-argcount code instr)
  (cond [(equal? code 'fetch-nil) (printf "\tmove.l\t#$0e,d0~n")]
        ;; for a procedure call we push the parameters and then the
        ;; number of parameters on the stack before we branch
        ;; to the subroutine.
        ;; After return we need to add the (4*(number of parameters+1))
        ;; bytes to the stack pointer to restore the state
        [(equal? code 'lookup-variable)
         (let ([varname (cadr instr)])
           (lookup-variable varname))]
        ;; string literals
        [(equal? code 'string-literal)
         (let ([litname (cadr instr)]
               [litval (caddr instr)])
           (printf "\talign\t2~n~a:\tdc.b\t\"~a\",0~n" litname litval))]
        ;; symbols
        [(equal? code 'symbol)
         (let ([symlabel (cadr instr)]
               [symval (caddr instr)])
           (printf "\talign\t2~n~a:\tdc.b\t\"~a\",0~n" symlabel symval))]
        [(equal? code 'fetch-str-literal)
         (printf "\tlea\t~a,a0~n\tmove.l\ta0,d0~n" (cadr instr))]
        [(equal? code 'fetch-symbol)
         (printf "\tlea\t~a,a0~n\tmove.l\ta0,d0~n" (cadr instr))]
        [(equal? code 'fetch-int-literal)
         (printf "\tmove.l\t#~a,d0~n\tasl.l\t#1,d0~n\tori.l\t#1,d0~n" (cadr instr))]
        [(equal? code 'lookup-env)
         (printf "\tlea\t~a,a0~n\tmove.l\ta0,-(a7)~n\tjsr\t_bl_tlenv_lookup~n\tadd.l\t#4,a7~n"
                 (cadr instr))]
        [(equal? code 'end-program)
         (printf "\tbra\tepilogue~n~n")]
        [(equal? code 'label)
         (printf "~a:~n" (cadr instr))]
        [(equal? code 'branch)
         (printf "\tbra\t~a~n" (cadr instr))]
        [(equal? code 'branch-false)
         (printf "\tcmpi.l\t#6,d0~n\tbeq\t~a~n" (cadr instr))]
        [(equal? code 'new-local-env)
         (printf "\tmove.l\t#~a,-(a7)~n\tjsr\t_bl_new_local_env~n\tadd.l\t#4,a7~n"
                 (cadr instr))]
        [(equal? code 'pop-local-env)
         (printf "\tmove.l\td0,-(a7)~n\tjsr\t_bl_pop_local_env~n\tmove.l\t(a7)+,d0~n")]
        [(equal? code 'local-lookup)
         (printf "\tmove.l\t#~a,-(a7)~n\tmove.l\t#~a,-(a7)~n\tjsr\t_bl_local_env_lookup~n\tadd.l\t#8,a7~n"
                 (caddr instr) (cadr instr))]
        [else (printf "~a~n" instr)]))

(define (translate-instr arg-counts instr)
  (let ([code (car instr)]
        [arg-count (car arg-counts)])
    ;; pushing a parameter should increment the parameter counter
    ;; we actually need to remember how many parameters are on the
    ;; stack, because the caller needs to remove the params
    (cond [(equal? code 'push) (printf "\tmove.l\td0,-(a7)~n")
                               (cons (+ arg-count 1) (cdr arg-counts))]
          [(equal? code 'apply)
           (printf "\tmove.l\t#~a,-(a7)~n" arg-count)
           (printf "\tjsr\t(a0)~n")
           (printf "\tadd.l\t#~a,a7~n" (* (+ arg-count 1) 4)) (cdr arg-counts)]

          [(equal? code 'tl-env-bind)
           (printf "\tjsr\t_bl_tlenv_bind~n\tadd.l\t#8,a7~n") (cdr arg-counts)]

          ;; there are 2 parameters, 1. the bound expression, 2. the slot
          [(equal? code 'local-env-bind)
           (printf "\tmove.l\t#~a,-(a7)~n\tjsr\t_bl_local_env_bind~n\tadd.l\t#8,a7~n"
                   (cadr instr)) (cdr arg-counts)]
          
          ;; push-continuation generates a new argument context
          [(equal? code 'push-continuation)
           ;; TODO
           (printf ";; TODO: push-continuation \"~a\"~n" (cadr instr))
           (cons 0 arg-counts)]
          ;; instructions that don't affect the argument count
          [else
           ;;(printf "\t;; code: ~a, arg-counts: ~a~n" code arg-counts)
           (translate-instr-preserve-argcount code instr)
           arg-counts])))

;; recursively translates the s-expressions coming from the input stream
;; and translating to m68k code.
;; the arg-counts argument is represents nested parameter counts
;; since many procedures are of variable length, the translation
;; needs to determine the number of arguments and push it on the stack
;; as the first argument
(define (translate-stream arg-counts in)
  (let ([instr (read in)])
    (cond [(not (eof-object? instr))
           (let ([new-arg-counts (translate-instr arg-counts instr)])
             (cond [(empty? new-arg-counts) (translate-stream '(0) in)]
                   [(translate-stream new-arg-counts in)]))])))

