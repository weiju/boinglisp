#lang racket
;; This backend translates the intermediate code generated by the compiler
;; stage into 68k code.
;; Currently the data model is as follows:
;;   - Values are 32 bit
;;   - integers (fixnum) are 31 bits and have their LSB set to 1
;;   - all other values have their LSB set to 0, currently this is
;;     - string pointer
(define (print-prologue)
  (printf "\tcode~n")
  (printf "\txdef\t_bl_main~n")
  (printf "\tcnop\t0,4~n")
  (printf "_bl_main:~n"))

(define (print-epilogue)
  (printf "\tcnop\t0,4~n")
  (printf "epilogue:~n")
  (printf "\tmoveq\t#0,d0~n")
  (printf "\trts~n"))

(define (lookup-variable varname)
  (cond [(eq? varname 'quote) (printf "\tlea\t_bl_quote,a0~n")]
        [(eq? varname 'println) (printf "\tlea\t_bl_println,a0~n")]
        [(eq? varname 'print) (printf "\tlea\t_bl_print,a0~n")]
        [(eq? varname '+) (printf "\tlea\t_bl_add,a0~n")]
        [(eq? varname '-) (printf "\tlea\t_bl_sub,a0~n")]
        [(eq? varname '*) (printf "\tlea\t_bl_mul,a0~n")]
        [(eq? varname '/) (printf "\tlea\t_bl_div,a0~n")]
        [else (printf "looking up: ~a~n" varname)]))

(define (translate-instr arg-counts instr)
  (let ([code (car instr)]
        [arg-count (car arg-counts)])
    ;; pushing a parameter should increment the parameter counter
    ;; we actually need to remember how many parameters are on the
    ;; stack, because the caller needs to remove the params
    (cond [(equal? code 'push) (printf "\tmove.l\td0,-(a7)~n")
                               (cons (+ arg-count 1) (cdr arg-counts))]
          [(equal? code 'apply)
           (printf "\tmove.l\t#~a,-(a7)~n" arg-count)
           (printf "\tjsr\t(a0)~n")
           (printf "\tadd.l\t#~a,a7~n" (* (+ arg-count 1) 4)) (cdr arg-counts)]
          [(equal? code 'push-continuation)
           ;; TODO
           (printf ";; TODO: push-continuation \"~a\"~n" (cadr instr))
           (cons 0 arg-counts)]
          [(cond [(equal? code 'fetch-nil) (printf "\tmove.l\t#$0e,d0~n")]
                 ;; for a procedure call we push the parameters and then the
                 ;; number of parameters on the stack before we branch
                 ;; to the subroutine.
                 ;; After return we need to add the (4*(number of parameters+1))
                 ;; bytes to the stack pointer to restore the state
                 [(equal? code 'lookup-variable)
                  (let ([varname (cadr instr)])
                    (lookup-variable varname))]
                 [(equal? code 'string-literal)
                  (let ([litname (cadr instr)]
                        [litval (caddr instr)])
                    (printf "\talign\t2~n~a:\tdc.b\t\"~a\",0~n" litname litval))]
                 [(equal? code 'fetch-str-literal)
                  (printf "\tlea\t~a,a0~n\tmove.l\ta0,d0~n" (cadr instr))]
                 [(equal? code 'fetch-int-literal)
                  (printf "\tmove.l\t#~a,d0~n\tasl.l\t#1,d0~n\tori.l\t#1,d0~n" (cadr instr))]
                 [(equal? code 'end-program)
                  (printf "\tbra\tepilogue~n~n")]
                 [(equal? code 'label)
                  (printf "~a:~n" (cadr instr))]
                 [else (printf "~a~n" instr)]) arg-counts])))

(define (translate-stream arg-counts in)
  (let ([instr (read in)])
    (cond [(not (eof-object? instr))
           ;;(println instr)
           (translate-stream (translate-instr arg-counts instr) in)])))

(define (il-to-asm filename)
  (let ([in (open-input-file filename)])
    (translate-stream in)))

(print-prologue)
(translate-stream '(0 0) (current-input-port))
(print-epilogue)
