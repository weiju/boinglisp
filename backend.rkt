#lang racket
;; This backend translates the
;; intermediate code generated by the compiler stage into
;; 68k code
(define (print-prologue)
  (printf "\tINCLUDE \"exec/exec.i\"~n")
  (printf "\tINCLUDE \"runtime_macros.i\"~n")
  (printf "\tbsr\tinit_runtime~n")
  (printf "\ttst.l\td0~n")
  (printf "\tbeq.s\terror~n"))

(define (print-epilogue)
  (printf "\tbsr\tcleanup_runtime~n")
  (printf "error:~n")
  (printf "\tmoveq\t#0,d0~n")
  (printf "\trts~n"))

(define (lookup-variable varname)
  (cond [(eq? varname 'quote) (printf "\tlea\tquote,a0~n")]
        [(eq? varname 'println) (printf "\tlea\tprint_str,a0~n")]
        [else (printf "looking up: ~a~n" varname)]))

(define (translate-instr instr)
  (let ([code (car instr)])
    (cond [(equal? code 'fetch-nil) (printf "\tlea\tnil_str,a0~n")]
          ;; pushing a parameter should increment the parameter counter
          ;; we actually need to remember how many parameters are on the
          ;; stack, because the caller needs to remove the params
          [(equal? code 'push) (printf "\tmove.l\ta0,-(a7)~n")]
          ;; TODO: this is a kludge, as a proof of princible,
          ;; we need to add the (4*number of parameters) bytes to the
          ;; stack to restore the state
          [(equal? code 'apply) (printf "\tjsr\t(a0)~n\taddq.l\t#4,a7~n")]
          [(equal? code 'lookup-variable)
           (let ([varname (cadr instr)])
             (lookup-variable varname))]
          [else (printf "~a~n" instr)])))

(define (translate-stream in)
  (let ([instr (read in)])
    (cond [(not (eof-object? instr))
           (translate-instr instr)
           (translate-stream in)])))

(define (il-to-asm filename)
  (let ([in (open-input-file filename)])
    (translate-stream in)))

(print-prologue)
(translate-stream (current-input-port))
(print-epilogue)
