* Design documentation

After some experimentation, the decision was made to write the runtime
library in C. This will lead to faster results as well as greater portability
and maintainability.

The code generated by the compiler backend will however be assembly for
Motorola 680x0 systems, mainly for better control and gaining understanding about
continuations and foreign function interfaces.

** Motorola 68k backend

The current BoingLisp compiler heavily relies on the tool chain
Racket -> VBCC/VASM -> 68k/Amiga machine code.

It follows that we need to make sure we understand how to integrate assembly
code for VASM and C code generated by VBCC.

The stack layout for a C function call is as follows:

    ------------------
    | Return address |
    ------------------
    | Argument 1     |
    ------------------
    | Argument 2     |
    ------------------
    | ...            |
    ------------------

C functions compiled by vbcc will in general return the result in Register d0,
unless it is a struct where depending on the size, the result either ends up in
the data registers or in the stack. Since all values passed between the compiled
code and the runtime library will fit in a machine word (BLWORD, 32 bit on m68k),
we can always assume that d0 will store the return value.

All runtime library functions will also return a value, even void has a defined
value (BL_UNDEFINED).

** Data Types

The general convention of other Scheme systems is followed that a machine word
is used to either store immediate values or a pointer type.

Immediate values are:

  - fixnum (LSB is 1)
  
